<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.4.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-07-23T09:22:45-10:00</updated><id>http://localhost:4000/</id><title type="html">Artemis</title><entry><title type="html">Wayland, Qt, and Swift vs. D</title><link href="http://localhost:4000/insights/design/wayland-qt-and-swift-vs-d/" rel="alternate" type="text/html" title="Wayland, Qt, and Swift vs. D" /><published>2017-07-15T00:00:00-10:00</published><updated>2017-07-15T00:00:00-10:00</updated><id>http://localhost:4000/insights/design/Wayland-Qt-and-Swift-vs-D</id><content type="html" xml:base="http://localhost:4000/insights/design/wayland-qt-and-swift-vs-d/">&lt;p&gt;Hello Artemis Community! I’m Wesley (some of you have probably met me in Telegram), and Marquis asked me to write this post about the stuff I’ve been posting and looking into recently. Basically I’ve been doing a lot of looking and reading as to how to actually accomplish what we are trying to do here with Artemis. &lt;!--more--&gt; At this point, we’re looking at creating a completely new project, rather than forking Unity7, which is seeming more and more like and endless amount of work for no really good reason. What I say below should be enough to explain that. This post is basically an overview of the technologies that are available to us and are mostly what we’re thinking about using. Enjoy!&lt;/p&gt;

&lt;h2 id=&quot;wayland&quot;&gt;Wayland&lt;/h2&gt;
&lt;p&gt;Every graphical desktop environment for Linux today has windows. They are a staple of every desktop experience. As it says on the main page of this site:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“The Artemis Project aims to bring the best environments to continue the venerable Unity 7 desktop in the modern Linux space.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Unity has windows, just like everyone else. Contrary to what you may have heard or thought, Unity is not actually controlling those windows. Yes, it defines how they look, but it doesn’t actually do any of the drawing.&lt;/p&gt;

&lt;p&gt;X does. X is a massive program that’s (current) job is to communicate between the Kernel, the compositor (the program that does the actual drawing), and the clients (each program that you run in a window).&lt;/p&gt;

&lt;p&gt;It didn’t always used to be like that. When X11 (the current version, the one that came out in &lt;strong&gt;1987&lt;/strong&gt;!) was released, X did all the drawing. But back then, people didn’t want to do a lot with their windows. They’d put some text and a button in them. But as X aged, people started to want to do more things. Play video. Do complex graphics. Fancy animations. So the problems that X was designed to solve went away, and were replaced with new ones. And instead of replacing X, X was modded and wrapped up in lots of layers to get the new functionality. Then it was stripped down and a lot of core functionality was removed, and outsourced to other programs. The long and short of it is, X no longer does much. It’s just a middleman (if you want a more complete understanding of X’s deficiencies, Daniel Stone, an ex-X dev and core Wayland dev gives a good talk explaining some of that stuff &lt;a href=&quot;https://www.youtube.com/watch?v=GWQh_DmDLKQ&quot;&gt;here&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Enter Wayland. Wayland is a protocol (not a program, just a way for programs to talk to each other) that is deigned to handle modern needs for window management, as well as drastically simplifying and speeding up window management and overall making the desktop experience better. Some of you will have heard that Fedora 25 under Gnome is Wayland by default (released in November of 2016). As for Artemis, our goals are, again,&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“…to continue the venerable Unity 7 desktop in the modern Linux space.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Using Wayland makes sense. Using X doesn’t. This is a learning process as to how everything needed to create a desktop shell works. Wayland provides us a clear base for that.&lt;/p&gt;

&lt;h3 id=&quot;compositors&quot;&gt;Compositors&lt;/h3&gt;
&lt;p&gt;Wayland is a protocol, not a program. It specifies how windows and programs are supposed to interact. A program called the Wayland Compositor talks to the Kernel and the clients (the programs you’re running in windows) to draw things to your screen. However, Wayland in of itself doesn’t do anything. It’s simply a bunch of rules governing how all those parts talk to each other. To actually create a desktop with Wayland, you need a compositor. There are a few.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;For starters, the guys who created Wayland have a refernece implementation of the protocol, which they have named Weston. Weston is not a production-grade tool. It is designed as a demo, and to be used as such.&lt;/li&gt;
  &lt;li&gt;Gnome’s compositor, Mutter, was ported from X for Wayland, and can run under either system.&lt;/li&gt;
  &lt;li&gt;Kwin is the compositor that is in development by the KDE guys.&lt;/li&gt;
  &lt;li&gt;Mir was the compositor used by Unity 8, and is still currently in use by Yunit. There has also been talk of using Mir for the MATE desktop environment.&lt;/li&gt;
  &lt;li&gt;And there is always the option to write our own, either from scratch or using some external library.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;gui-toolkit&quot;&gt;Gui Toolkit&lt;/h2&gt;
&lt;p&gt;As it stands, there are two common high-level toolkits for creating gui applications. Most of you will have heard of them. They are GTK+ and Qt. GTK+ is the toolkit the Gnome project develops and is used in the Gnome shell, as well as many older desktops. Qt is independently developed by the Qt company, and is open source, although it is also availabe under a commercial license.&lt;/p&gt;

&lt;p&gt;Because GTK+ is written in C, it is very easy for many languages to interface to it. However, because it is developed by the Gnome project, it leans toward their goals for their desktop shell, more so now than in the past.&lt;/p&gt;

&lt;p&gt;On the other hand, Qt is independently developed in C++. Qt is more feature-rich than GTK+, and behaves more like a framework. I’ll talk more about languages further down, but none of us who would actually be designing and building Artemis want to be writing in C++, even less than we’d want to write in C. C++ is also harder to interface to from other languages.&lt;/p&gt;

&lt;p&gt;A final decision has not been made this early in the planning process, but we are currently leaning towards Qt, especially given some language considerations (see below).&lt;/p&gt;

&lt;h2 id=&quot;languages&quot;&gt;Languages&lt;/h2&gt;
&lt;p&gt;C was a well designed language. It’s still pretty good for systems programming, but it’s just not high-level enough for the applications layer that we are working on. C++ is… archaic, inimical, and abtruse, not to mention being… less well-designed than C. We are looking for better tools to use to build Artemis than C/C++. Specifically, D vs. Swift is the argument we continue to have in the IM system. Let’s take a deeper look at both of these. I’ll try to hold my personal opinion for this.&lt;/p&gt;

&lt;h3 id=&quot;both&quot;&gt;Both&lt;/h3&gt;
&lt;p&gt;Swift and D are similar. Like C/C++, they are compiled languages, so they tend to run faster than something like Python. They are also both open-source languages, so there are no legal issues we would run into using either language. They are both designed with systems programming in mind, and are both multi-paradigm (allowing for object-oriented and functional programming, among others). They can both dynamically and statically link to existing C libraries. They are both statically typed (meaning that the compiler knows the type of each variable at compile time).&lt;/p&gt;

&lt;h3 id=&quot;swift&quot;&gt;&lt;a href=&quot;https://swift.org&quot;&gt;Swift&lt;/a&gt;&lt;/h3&gt;
&lt;!--Original: Swift was designed by Apple Inc.(No, this does not immediately make it trash) and was open-sourced within the last five years. It was designed as a replacement for Objective-C, to allow for easier development of applications. Currently the swift compiler only officially supports Ubuntu and Mac OSX, although the source can be downloaded and compiled on any Linux-based OS, provided that you have the correct libraries installed. Swift is designed with memory safety in mind, and therefore does not allow the programmer to use pointers or do unsafe memory operations. It is garbage collected. Swift is statically typed, but it uses type inference. It's syntax is lighter than C's (semicolons are not necessary at the end of every line, although they can be used), and removes things like the increment and decrement operators (++ and --, it uses += and -= instead), as well as removing traditional for-loops.--&gt;

&lt;p&gt;Swift was designed by Apple Inc.(No, this does not immediately make it trash) and was open-sourced within the last five years. It was designed as a replacement for Objective-C, to allow for easier development of applications. Currently the swift compiler only officially supports Ubuntu and Mac OSX, although the source can be downloaded and compiled on any Linux-based OS, provided that you have the correct libraries installed. Swift is designed with memory safety in mind, and therefore uses pointers, bitcasts, and memory rebounds. It implements &lt;em&gt;automatic reference counting&lt;/em&gt; during compilation; therefore, memory is easily managed. Swift is statically typed, but it uses type inference. Its syntax is lighter than C’s (semicolons are not necessary at the end of every line, although they can be used), and removes things like the increment and decrement operators (++ and –, it uses += and -= instead), as well as removing traditional for-loops.&lt;/p&gt;

&lt;h3 id=&quot;d&quot;&gt;&lt;a href=&quot;https://dlang.org&quot;&gt;D&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;D was designed by two very experienced C++ and was designed to be what C++ should have been. It has all the power of low level C (allowing programmers to use pointers and other manual memory management), but also has many of the conveniences of higher-level scripting languages (dynamic arrays, built-in associative arrays or hashmaps, a foreach loop, and is garbage collected by default(although the gc can be turned off)). D’s syntax is vary similar to C’s. A piece of C code without any preprocessor directives will compile on a D compiler, and behave the same way it did when being compiled with a C compiler. Compiled D code is completely compatible with compiled C and C++ code.&lt;/p&gt;

&lt;h3 id=&quot;toolkit-bindings&quot;&gt;Toolkit Bindings&lt;/h3&gt;
&lt;p&gt;Both of these languages have a well-supported and actively developed binding to GTK. Neither have a solid binding to Qt. However, Andreas Schulz (&lt;a href=&quot;https://github.com/Longhanks&quot;&gt;Longhanks&lt;/a&gt; on github) is in the early stages of creating a C wrapper around Qt. His end goal is to create a swift binding for this C library (it already works!). With very little effort, this C binding could also be used as the base for a D binding. If anyone has any experience, help would be appreciated on the binding front.&lt;/p&gt;

&lt;p&gt;Thanks for reading folks! This is a fairly accurate summary of what is on my mind as I apply myself to the problem of developing Artemis, and what we’re trying to do right now. We appreciate the continued support.&lt;/p&gt;</content><author><name>Wesley Hershberger</name></author><summary type="html">Hello Artemis Community! I’m Wesley (some of you have probably met me in Telegram), and Marquis asked me to write this post about the stuff I’ve been posting and looking into recently. Basically I’ve been doing a lot of looking and reading as to how to actually accomplish what we are trying to do here with Artemis.</summary></entry><entry><title type="html">Huzzah! Hello, …!</title><link href="http://localhost:4000/insights/design/huzzah-hello-artemis/" rel="alternate" type="text/html" title="Huzzah! Hello, ...!" /><published>2017-05-25T00:00:00-10:00</published><updated>2017-05-25T00:00:00-10:00</updated><id>http://localhost:4000/insights/design/Huzzah</id><content type="html" xml:base="http://localhost:4000/insights/design/huzzah-hello-artemis/">&lt;p&gt;After a successful five days of voting, I am pleased to introduce the new name for the Enjade Project. It was a close battle between several names, but the decision has been made… by you, the community!&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/name-survey-distribution.png&quot; alt=&quot;Distribution&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;interesting-results-runners-up&quot;&gt;Interesting results: Runners-up&lt;/h2&gt;
&lt;p&gt;During the five days, we received a total of &lt;em&gt;75&lt;/em&gt; responses from all over the world.It was amazing looking at each and every individual vote, seeing the overall distribution of the possible names for the project. To remind you, we had the following choices: Artemis, Chrysalis, Desiree, Cambria, Ka’iulani, ‘Other’, and a combo of the aforementioned names.&lt;/p&gt;

&lt;p&gt;A lot of people had some interesting names in the ‘Other’ section, including (but not limited to):&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;My ass (my personal favorite 😂 )&lt;/li&gt;
  &lt;li&gt;New Unity Desktop Environment (NUDE)&lt;/li&gt;
  &lt;li&gt;GNUDE&lt;/li&gt;
  &lt;li&gt;Junity&lt;/li&gt;
  &lt;li&gt;commUnity&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With that in mind, the fight between &lt;em&gt;Desiree&lt;/em&gt; and &lt;em&gt;Chrysalis&lt;/em&gt; ensued, crushing Cambria and Ka’iulani. I can assure you that some of our services and tools for the desktop project will have these names because of their little skirmish.&lt;/p&gt;

&lt;h2 id=&quot;drumroll-please&quot;&gt;Drumroll, please!&lt;/h2&gt;
&lt;p&gt;The moment you’ve been waiting for is here!
 &lt;/p&gt;

&lt;p&gt; &lt;/p&gt;
&lt;h4 id=&quot;the-new-name-for-the-enjade-project-is-artemis&quot;&gt;&lt;strong&gt;&lt;em&gt;The new name for the Enjade Project is… Artemis!&lt;/em&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt; &lt;/p&gt;

&lt;p&gt;I heavily thanks the community for their input on the new name for this beloved project, and I can’t wait to see what the next survey will hold! There’s a few things I want to make sure you all know before we get underway with this:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The next survey will be about theming and Artemis’s official logo, used for the Dash icon. Please, go to the ‘Get Involved’ page, join the Telegram group, and submit your logos there!&lt;/li&gt;
  &lt;li&gt;For now, the GitHub Pages, repo, and Telegram URLs will continue to be labeled as “Enjade Project”. This will get fixed eventually when we get a new URL and find a way to block ‘Enjade’ as the name of the entire project out of our heads.&lt;/li&gt;
  &lt;li&gt;With that in mind, the ‘Enjade’ name will stay, probably for an API or something like that.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Thanks, folks, for your suggestions! We’re making progress with Artemis, and we’re excited to release something soon.&lt;/p&gt;</content><author><name>Marquis Kurt</name></author><summary type="html">After a successful five days of voting, I am pleased to introduce the new name for the Enjade Project. It was a close battle between several names, but the decision has been made… by you, the community!</summary></entry><entry><title type="html">We need your help with renaming Enjade</title><link href="http://localhost:4000/insights/design/help-rename-enjade/" rel="alternate" type="text/html" title="We need your help with renaming Enjade" /><published>2017-05-21T00:00:00-10:00</published><updated>2017-05-21T00:00:00-10:00</updated><id>http://localhost:4000/insights/design/Help-rename-Enjade</id><content type="html" xml:base="http://localhost:4000/insights/design/help-rename-enjade/">&lt;p&gt;When I first started the Enjade project, I wanted to give a name that best represented the clean, friendly nature of the Unity desktop while presenting something completely new. Sadly, things have changed and not everything is what it seems.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;what-happened&quot;&gt;What happened?&lt;/h2&gt;
&lt;p&gt;I won’t go into details as to what exactly prompted this decision to rename the project, but I have come to the realization that the person we named the project after doesn’t best reflect the values and mission of the desktop project. I was quite shocked when I realized this as nothing negative happened for the past two months; however, things gave way and I had to go for the renaming. As much as I love the cool name of “Enjade”, it’ll keep haunting everyone of the failure of finding Amour Sans for &lt;a href=&quot;http://www.acquaintedsafari.ga&quot;&gt;A.Safari&lt;/a&gt;. I had the impression that, in properly naming the project to &lt;em&gt;Enjade&lt;/em&gt;, I would clearly express the openness and the friendliness of the Unity desktop that Canonical had worked on since Ubuntu 11.04 and that the person Enjade was named after would feel proud (adn flattered, I supposed), to have an entire project that resounds with such a friendly personality and may be moved to join the project. I was wrong on both counts.&lt;/p&gt;

&lt;h2 id=&quot;what-will-happen-now&quot;&gt;What will happen now?&lt;/h2&gt;
&lt;p&gt;The continuation of the Unity desktop will still happen, and there will still be Core and Pure. This won’t change as the desktop environment is what started the project in the first place; I don’t want to shut down a growing, loving community working on a beautiful, open, and friendly desktop. However, we’ll need you help to not make the same mistake. We have a survey to discuss possible names; please, take the time to fill out this survey. This will help rebrand the project to something that is more reflective of the project.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://goo.gl/forms/OUSwuDEsRHiT0Y9N2&quot;&gt;Take the survey ›&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Thank you for taking the time to read this and help make the project even better. To give you some hope, I am excited to tell you that we are in the process of renaming the Pure code right now and are on track to making a build in the forseeable future.&lt;/p&gt;</content><author><name>Marquis Kurt</name></author><summary type="html">When I first started the Enjade project, I wanted to give a name that best represented the clean, friendly nature of the Unity desktop while presenting something completely new. Sadly, things have changed and not everything is what it seems.</summary></entry><entry><title type="html">New site, changed views, and a brighter future</title><link href="http://localhost:4000/insights/design/a-new-site/" rel="alternate" type="text/html" title="New site, changed views, and a brighter future" /><published>2017-05-07T00:00:00-10:00</published><updated>2017-05-07T00:00:00-10:00</updated><id>http://localhost:4000/insights/design/A-new-site</id><content type="html" xml:base="http://localhost:4000/insights/design/a-new-site/">&lt;p&gt;When I first started this project back in April, I had no clue as to how the entire project would play out. I thought that I would be by myself on it, having to create and maintain an entire environment with little to no help. After all, I do see comments regularly that show that users’ disliking of the Unity desktop project. To my surprise, I was wrong; currently, there are ~30 members in the Telegram group for the Enjade Project, some base ideas for how the entire project will roll out, and an article on OMG! Ubuntu featuring the project.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;enjade-is-growing&quot;&gt;Enjade is growing&lt;/h2&gt;
&lt;p&gt;The Enjade Project has been accelerating at such a great speed. We’ve created a decent roadmap for what features we plan to implement in the desktop environment. We’ve already begun discussing new Plasmoids to introduce to the Plasma environment to bring about the new Unity, such as the Enjade Launcher. Now, we have a decent-looking website with Ubuntu’s freely-avaialable CSS, adding a cohesive Unity feel rather than a simple one-page solution.&lt;/p&gt;

&lt;p&gt;I’m excited to see the future of Enjade unfold; it seems as if I have made a good investment in resurrecting the Unity desktop in such a way that will combine the core of the environment while including progression of modern Linux technologies like Wayland. I am also anticipating how Enjade will become more than just a Unity replica; I’m overseeing the future of the Unity desktop through Enjade.&lt;/p&gt;

&lt;h2 id=&quot;introducing-enjade-core-and-enjade-pure&quot;&gt;Introducing Enjade Core and Enjade Pure&lt;/h2&gt;
&lt;p&gt;Today, I’m pleased to announce that ther will be two versions of the Enjade desktop for Linux users. The first is the Enjade desktop you are already familiar with with a Plasma-based environment: Enjade Core. Enjade Core will be the first to get new features and innovations in the acclaimed environment. In addition to this, we will ship a version of Ubuntu LTS with this desktop pre-installed, making it easy for transition. This distribution is not the same distribution as &lt;a href=&quot;http://viva.acquaintedsafari.ga&quot;&gt;VivaOS&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The other version of Enjade is one that should have already existed (but didn’t). For many, users don’t really notice or expect the latest and greatest innovations; in fact, there are users who still prefer X11 and Compiz over Wayland, and that’s understandable. So, today, I’m pleased to introduce a new version of the Enjade Project that continues the direct work of the Unity desktop: Enjade Pure.&lt;/p&gt;

&lt;h3 id=&quot;why-enjade-pure&quot;&gt;Why Enjade Pure?&lt;/h3&gt;
&lt;p&gt;Enjade Pure is a direct fork of the Unity 7 desktop environment, unlike Enjade Core, considered a “pseudo-fork”. Enjade Pure retains the core essence and overall functionality of the Unity 7 desktop, but will get the features from Enjade Core. We’re also planning to ship a distribution of Ubuntu (regular release) with Enjade Pure. Enjade Pure will receive features after they’ve been implemented in Enjade Core.&lt;/p&gt;

&lt;p&gt;Retaining the original Unity desktop while pumping in new features can make it easy for a user to transition to another desktop, especially if that user doesn’t care about using the latest and greatest software. As Enjade Core is a fledgling desktop environment, Enjade Pure offers a reliable and well-built environment, based off of the original Unity. In addition to this, Compiz Reloaded continues the work of Compiz, so it may be possible that Enjade Pure can continue to exist in modern ways. It could also be possible that Enjade Pure will work off of Mutter, continuing the beloved desktop.&lt;/p&gt;

&lt;p&gt;Consider this a birthday gift, &lt;a href=&quot;http://www.instagram.com/jaenoelani&quot;&gt;@Jaeden Gurrero&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;a-clearer-feature-roadmap&quot;&gt;A clearer feature roadmap&lt;/h2&gt;
&lt;p&gt;Because of this, a new feature roadmap will be implemented that covers the general timeframe of Enjade’s releases and implementations. The new roadmap will be hosted on this site and can be found by clicking “Features” in the navigation bar of the main site.&lt;/p&gt;

&lt;p&gt;Thank you for being a part of this community, and I can’t wait to see what’s next with Enjade.&lt;/p&gt;</content><author><name>Marquis Kurt</name></author><summary type="html">When I first started this project back in April, I had no clue as to how the entire project would play out. I thought that I would be by myself on it, having to create and maintain an entire environment with little to no help. After all, I do see comments regularly that show that users’ disliking of the Unity desktop project. To my surprise, I was wrong; currently, there are ~30 members in the Telegram group for the Enjade Project, some base ideas for how the entire project will roll out, and an article on OMG! Ubuntu featuring the project.</summary></entry></feed>